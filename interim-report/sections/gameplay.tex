\section{Gameplay}
In this section a high level description of the gameplay will be outlined.
We can describe the gameplay with the below psuedocode.

\vspace{0.3cm}

\begin{algorithm}[H]
    start server\;
    wait for minimum connections\;
    launch game\;
    \While{players $>$ 1}{
        deal cards to each player\;
        \For{each betting round while (players in play $>$ 1)}{
            prompt each player for action\;
            evaluate actions\;
            reveal next set of cards\;
        }
        update player chips counts\;
        remove players with no chips\;
    }
\caption{The poker server algorithm}%
\label{code:pokerServer}
\end{algorithm}

\vspace{0.3cm}

We can now talk about each step of the implementation in more detail, and the
problems encountered. Once a player connects to the server, upon receiving
an initial message from the server, the developed client then launches
a GUI, which is talked about more in depth in its relevant section.

Card dealing has been abstracted, and as mentioned in the randomness section,
is adaptable, and supports multiple different card picking and randomness
sources. A new deck is initiated each round, with the chosen card picking
and randomness sources. There are currently three different methods of
picking a card.

\begin{itemize}
    \item Knuth Shuffle
    \item Random Indexing
    \item Random Sorting Shuffle
\end{itemize}

The knuth shuffle \parencite{knuth1997} can be implemented like so:

\vspace{0.3cm}

\begin{algorithm}[H]
    \SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
    \Input{An array $xs$ of cards, a function $getRandomNumber$}
    \Output{$xs$ shuffled}
    \BlankLine{}
    \For{$i \leftarrow length (xs) - 1$ \KwTo{} 1}{
        $j \leftarrow getRandomNumber (i)$\;
        swap ($xs$, $i$, $j$)\;
    }
    return $xs$\;
\caption{The knuth shuffle algorithm}
\end{algorithm}

\vspace{0.3cm}

This algorithm produces uniformly distributed permutations, assuming the
getRandomNumber function produces random numbers between 0 and i. However,
a very similar version, which instead of swapping between i and j, swaps
between 0 and j is not uniformly distributed. This can be proven by
the fact that there are $n^n$ possible sequences of random numbers, whereas
there are ${n!}$ possible permutations, which is not a factor of $n^n$.
The knuth shuffle however can produce exactly ${n!}$ possible random number
sequences. \parencite{website:rici2015}

The random indexing card picking algorithm is very simple, and simply involves
taking a random number r between 0, and the length of the card deck, and
removing item r from the array.

The random sorting shuffle is less simple and again is described below:

\vspace{0.3cm}

\begin{algorithm}[H]
    \SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
    \Input{An array $xs$ of cards, a function $getRandomNumber$}
    \Output{$xs$ shuffled}
    \BlankLine{}
    $randomNums \leftarrow []$\;
    \For{$i \leftarrow 0$ \KwTo{} length ($xs$)}{
        randomNums += getRandomNumber (${2}^{32}$)\;
    }
    $combined \leftarrow zip$ (xs, randomNums)\;
    $sorted \leftarrow sortBy ( combined, compare (snd))$\;
    return map (fst, $sorted$)\;
\caption{The random sort shuffle algorithm}
\end{algorithm}

\vspace{0.3cm}

The above algorithm generates a random number for each card, and assigns
one to each in a list of tuples. The list is then sorted by the random numbers,
and the random numbers are then thrown away, and the list is returned. One
possible pitfall of this algorithm is if the numbers generated are the same,
however the probability of this happening is very small, and is discussed
in the randomness section.

Action evaluation is done by simply updating a state monad which is threaded
between all the main functions. For example, if a player makes a raise action,
the minimum raise will be updated, the current bet will be updated, and
the players bet and chips will be updated. These actions are propogated to the
clients when neccessary to update their GUI's. Unlike a global variable,
a state monad is a pure function, taking an old state and returning a new
state. The makes the code a lot easier to reason about, being able to test
out individual functions in the Haskell GHCI interpreter with a custom state
inputted, rather than having to run a complex series of functions to get the
global state in a suitable condition to test the functionality. The state
monad is also using the StateT monad transformer. This allows us to use IO
impure functions whilst still remaining in the state monad. Due to the
setup of our type signatures, pure code is still in the StateT monad, but
has an abstract type signature, so is prevented from running IO effectful code.
In this way, we maintain ease of use, being able to call pure code in IO
functions without unwrapping or lifting state monads, whilst being able to
indicate impure functions in the type signature.

The client and server programs interact using the network library, which
uses low level sockets to send messages to each other. The messages are queued
and decoded one at a time on either side, as multiple messages can be packed
into one read for efficiency. The messages are encoded with an efficient binary
protocol to reduce the amount of data needing to be sent over the network.
Even without these optimisations, due to the data being essentially text, the
bandwidth needed to transfer the messages is very minimal.

In the client, upon receiving a message, it will decode it, and depending upon
the message type, it will generally update the internal state of the gameplay,
then update the GUI to reflect these changes. Upon being prompted for an
input, the related dialog boxes or buttons will be enabled and visible.
Once an input is selected, this will be encoded and sent back to the server.

The AI is implemented in nearly the exact same way as the client. A framework
was developed which takes care of updating the internal state and passing the
messages back and forth, so all that is needed to create a new AI is to
implement a function which takes a list of valid inputs, and the current
states, and returns a valid action. This enables a very simple AI to be
implemented in very few lines of code. For example, the random AI, which simply
picks a random action and a random raise size, if raise is selected, can
be implemented in 10 lines of code.

All inputs are validated on the server. This prevents malicious or faulty
clients from sending illegal or invalid messages which could alter their
standings or possibly crash the server. However, currently messages are not
encrypted went they are sent, which could allow malicious parties to man in the
middle the connection and alter the players actions. In future, we could look
into possible encryption techniques to secure this avenue of exploitation.
